^X
 3️⃣ CHECK-IN FLOW VALIDATION
-- ============================================

begin;

-- Ensure extensions are available
create extension if not exists pgcrypto with schema extensions;
create extension if not exists postgis;

-- Setup
do $$
declare
  v_user_id uuid := extensions.gen_random_uuid();
  v_event_id uuid;
  v_totp_secret bytea;
  v_token text;
  v_ticket_data record;
  v_result record;
  v_code int;
begin
  -- Create auth.users FIRST (trigger auto-creates public.users)
  insert into auth.users (id, email, encrypted_password, email_confirmed_at, created_at, updated_at)
  values (v_user_id, 'checkin_test@example.com', extensions.crypt('password', extensions.gen_salt('bf')), now(), now(), now())
  on conflict (id) do nothing;
  
  perform pg_sleep(0.1);
  
  -- Create event
  v_event_id := yombri.create_event(
    p_actor_id => v_user_id,
    p_title => 'Check-in Test Event',
    p_description => 'Testing all check-in methods',
    p_starts_at => now() + interval '1 hour',
    p_ends_at => now() + interval '3 hours',
    p_lat => 37.7749,
    p_lng => -122.4194,
    p_address_label => 'San Francisco, CA',
    p_checkin_radius_m => 150
  );
  
  raise notice 'Created event: %', v_event_id;
  
  -- Get TOTP secret for testing
  select totp_secret into v_totp_secret
  from public.event_secrets
  where event_id = v_event_id;
  
  -- Test 1: Magic check-in with valid location
  raise notice '--- Test: Magic check-in with valid geo ---';
  
  select * into v_result
  from yombri.verify_check_in(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_lat => 37.7749,
    p_lng => -122.4194
  );
  
  assert v_result.status = 'checked_in', 'Should be checked in';
  assert v_result.checkin_method = 'geo', 'Method should be geo';
  raise notice 'PASS: Geo check-in succeeded';
  
  delete from public.event_participants where event_id = v_event_id and user_id = v_user_id;
  
  -- Test 2: Magic check-in with token
  raise notice '--- Test: Magic check-in with token ---';
  
  select token into v_token
  from yombri.mint_event_token(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_ttl_seconds => 300
  );
  
  select * into v_result
  from yombri.verify_check_in(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_event_token => v_token
  );
  
  assert v_result.status = 'checked_in', 'Should be checked in with token';
  assert v_result.checkin_method = 'qr', 'Method should be qr';
  raise notice 'PASS: Token check-in succeeded';
  
  delete from public.event_participants where event_id = v_event_id and user_id = v_user_id;
  
  -- Test 3: TOTP check-in
  raise notice '--- Test: TOTP check-in ---';
  
  v_code := yombri.totp_code(v_totp_secret, now(), 30, 6, 0);
  raise notice 'TOTP code: %', v_code;
  
  select * into v_result
  from yombri.verify_check_in_totp(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_code => v_code,
    p_client_time => now()
  );
  
  assert v_result.status = 'checked_in', 'Should be checked in with TOTP';
  assert v_result.checkin_method = 'totp', 'Method should be totp';
  raise notice 'PASS: TOTP check-in succeeded';
  
  delete from public.event_participants where event_id = v_event_id and user_id = v_user_id;
  
  -- Test 4: Offline ticket issuance and sync
  raise notice '--- Test: Offline ticket flow ---';
  
  insert into public.event_participants (event_id, user_id, status)
  values (v_event_id, v_user_id, 'joined');
  
  select * into v_ticket_data
  from yombri.issue_offline_ticket(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_ttl_hours => 24
  );
  
  assert v_ticket_data.ticket is not null, 'Ticket should be issued';
  raise notice 'Offline ticket issued: %', substring(v_ticket_data.ticket, 1, 20) || '...';
  
  delete from public.event_participants where event_id = v_event_id and user_id = v_user_id;
  insert into public.event_participants (event_id, user_id, status)
  values (v_event_id, v_user_id, 'joined');
  
  select * into v_result
  from yombri.sync_offline_check_in(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_method => 'geo',
    p_occurred_at => now() - interval '10 minutes',
    p_ticket => v_ticket_data.ticket
  );
  
  assert v_result.status = 'checked_in', 'Should be checked in after offline sync';
  assert v_result.initially_offline = true, 'Should be marked as initially offline';
  assert v_result.offline_synced_at is not null, 'Should have sync timestamp';
  raise notice 'PASS: Offline sync succeeded';
  
  -- Test 5: Idempotency
  raise notice '--- Test: Idempotency ---';
  
  select * into v_result
  from yombri.verify_check_in_totp(
    p_actor_id => v_user_id,
    p_event_id => v_event_id,
    p_code => v_code,
    p_client_time => now()
  );
  
  assert v_result.status = 'checked_in', 'Should remain checked in';
  raise notice 'PASS: Idempotent check-in works';
  
end $$;

rollback;
